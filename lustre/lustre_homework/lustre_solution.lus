


-----------------------------------------------------------------
-- Boolean Switch
--
-- Model a switch with two buttons, Set and Reset.
-- Pressing Set turns the switch on.
-- Pressing Reset turns the switch off
-- If Set and Reset are initially both unpressed,
-- the initial position of the switch is determined by
-- a third signal, Init

node Switch( Set, Reset, Init : bool ) returns ( X : bool );
let

    X = if Set then true 
           else if Reset then false
           else (Init -> pre X);
tel

node Switch2( Set, Reset, Init : bool ) returns ( X : bool );
let
  X = if Reset then false else
        if Set then true else
          (Init -> pre(X));
tel


node Switch3( Set, Reset, Init : bool ) returns ( X : bool );
let
  X = Set or (not Reset and (Init -> pre(X))) ;
tel


------------------------------------------------------------------
-- The following observer expresses 3 safety requirements
-- for the first switch.
--
-- ./luke le.lus --node ReqSwitch --verify

node ReqSwitch( Set, Reset, Init : bool )
returns ( R1, R2, R3 : bool );
var X : bool;
let
  X = Switch( Set, Reset, Init );

  -- setting turns the switch on
  R1  =  (Set => X);  -- not Set or X;
  
  -- resetting turns the switch off
  R2 =  (not Set and Reset) =>  not X;
  
  -- doing nothing maintains the previous value
  R3 = true -> ((not Set and not Reset) => X = pre X);
tel




-----------------------------------------------------------------
-- We would like to prove that:
--
--   "if Set and Reset are never true at the same time,
--    then Switch and Switch2 behave in the same way"
-- 

node ReqSwitches( Set, Reset, Init : bool ) returns ( OK : bool );
var X, X2 : bool;
let
  X  = Switch ( Set, Reset, Init );
  X2 = Switch2( Set, Reset, Init );

 -- OK = not (Set and Reset) => X = X2;

  OK = Sofar(not (Set and Reset)) => X = X2;
tel

-----------------------------------------------------------------
-- Show that: 
-- "the Switch node ignores its input Reset when the
-- input Set is true"
--
-- ("Ignoring" means that the behavior of Switch is exactly the 
--  same, independent of the value of Reset when Set is true.)
--

node SwitchIgnoresReset( Set, Reset, Reset2, Init : bool )
returns ( OK : bool );
let 











  OK =  Set => Switch(Set, Reset, Init) =
               Switch(Set, Reset2, Init);
 
tel


-----------------------------------------------------------------
-- Now, we would like to prove that:
--
--   R1 - "if the switch is on, 
--         it stays so until the next reset"
--
--   R2 - "if the switch is off, it stays so until the next set"
--



-- Equivalently:
-- 
-- R1 - "if we did not reset since the last time we set, 
--       X is true"
-- R2 - "if we did not set since the last time we reset,
--       X is false"

node ReqSwitchSetIgnoresReset( Set, Reset, Init : bool )
returns ( R1, R2 : bool );
var X : bool;
let
  X = Switch( Set, Reset, Init );


  --   "if we did not reset since the last time we set,
  --   X is true"
  R1 = Since( Set, not Reset ) => X;
  
  --   "if we did not set since the last time we reset,
  --   X is false"
  R2 = Since( Reset and not Set, not Set ) => not X;
tel




node ParallelCounters (a, b, c: bool) returns (x, y: int);
var n1,n2: int; 
let
  n1 = 10; 
  n2 = 5;
  x = 0 -> if (b or c) then 0 
           else if a and (pre x) < n1 then (pre x) + 1
           else pre x;
  y = 0 -> if c then 0
           else if a and (pre y) < n2 then (pre y) + 1
           else pre y; 

  -- Properties
  -- 1) Whenever x reaches n1, y reaches n2

tel

-----------------------------------------------------------------




-- prove that the node N below ignores its second input

node N (I, X: int) returns (Z: int);
let
  Z = I + 2;
tel

--node IgnoresFirstInput(X, Y,  V: int) return(R1: bool);
--let
--  R1 =  N(X, Y) = N(X, V);
--tel



-----------------------------------------------------------------
--  an integer switch
--
-- Model an integer switch with a button and an 
-- integer input X.
-- When the button is pressed the switch takes the value of X
-- and maintains it until the next time the button is pressed
-- again.
-- Before the button is pressed for the first time, the value of
-- X is 0.


node SwitchInt( Set : bool; X : int ) returns ( Y : int );
let
  Y = if Set then X else (0 -> pre Y);
tel

-----------------------------------------------------------------
--  Prove that:
--
--   "the SwitchInt node ignores its integer input X 
--    when the input Set is false"

node SwitchIgnoresX( Set : bool; X1, X2: int )
returns ( OK : bool );
var Env : bool;
let
  Env =  not Set;
  OK  =  Env => SwitchInt(Set, X1) = SwitchInt(Set, X2);






   
--   Env = Sofar(Set => X1 = X2);
--   OK  = Env => SwitchInt(Set,X1) = SwitchInt(Set,X2);
tel

-----------------------------------------------------------------
-- Prove that:
--
--   "Y always has the latest set value of X"
--
--  Let us first do a simple version of this:
--
--   "If we have not set the switch again since the last time 
--    the switch was set to 3, then Y must be 3"

node ReqSwitchInt_Simple( Set : bool; X : int ) returns ( OK : bool );
var Y : int;
let
  Y = SwitchInt( Set, X );










  OK = Since(Set and X = 3, not Set) => Y = 3;

tel

-----------------------------------------------------------------
--  To prove that:
--
--   "Y always has the latest set value of X"
--
--   Equivalently, 
--
--   "For all values a, 
--    if we have not set the switch again since the last time 
--    the switch was set to a, then Y must be a"
--
node ReqSwitchInt( Set : bool; X : int; A : int )
returns ( OK : bool );
var Y : int; a : int;
let
  a = First( A );
  Y = SwitchInt( Set, X );

  OK = Since( Set and X = a, not Set ) => Y = a;

tel



-- HasHappened(X) is true precisely when X has been true 
-- at least once since the first instant

node HasHappened(X : bool) returns (Y : bool);
let
  Y = X or (false -> pre Y);
tel


----------------------------------------------------
-- Write an observer that checks the following 
-- for an integer input stream Y: 

-- Whenever Y has the positive value x, 
-- its opposite -x has occurred in Y before

-- x is the first value of an additional 
-- input stream X

node NegBefore(Y: int; X : int) returns (OK : bool);
var x : int;
let
  x = First(X);
  OK =  (Y = x and x > 0) => HasHappened(Y = -x);
tel


-- write a simulator for NegBefore, 
-- a node that feeds to NegBefore a suitable streams
-- for Y and X

-- We write a node G whose output Y cycles through [-3..3]
-- if its integer input X is initially even, and
-- cycles through  [0..3] otherwise.

node Even(X: int) returns (Y: bool);
let
  Y =  2*(X div 2) = X;
tel


node G(X: int) returns(Y : int);
var preY,  lb : int;
let
  lb = if Even(First(X)) then -4 else -1;
  preY = lb -> pre Y;
  Y = if preY < 3 then preY + 1
                   else lb + 1;
tel



node Simul(X: int) returns (OK: bool);
var Y: int;
let
  Y = G(X);
  OK = NegBefore(Y, X);
tel








node TrafficLight( Button : bool )
returns ( Red, Yellow, Green, Walk, DontWalk : bool );

var Phase, prePhase : int;
let
  prePhase = 0 -> pre Phase;
  Phase    = if Button
               then 1
               else if prePhase > 0 and prePhase < 10
                      then prePhase+1
                      else 0;
  
  Green    = Phase = 0;
  Yellow   = Phase = 1;
  Red      = Phase > 1;
  
  Walk     = Phase > 2 and Phase < 10;
  DontWalk = not Walk;
tel


node ReqTrafficLight( Button : bool )
returns (R1, R2, R3, R4, R5, R6, R7, R8, R9, R10: bool);

var  CarsAllowed, Red, Yellow, Green, Walk, DontWalk : bool;
let
  (Red, Yellow, Green, Walk, DontWalk) = TrafficLight(Button);


  -- R1: Walk is never on when cars are allowed
  -- R2: Red and Green are never on at the same time
  -- R3: at all times one of the tree colored lights is on
  -- R4: Walk is on only if Red is
  -- R5: Walk and DontWalk are mutually exclusive
  -- R6: Red cannot immediately follow Green
  -- R7: Walk is not on is cars were allowed in the previous step 
  -- R8: Cars are not allowed if Walk was on in the previous step 
  -- R9: Yellow is on for at most one step
  -- R10: Red changes directly to green

  CarsAllowed = Green or Yellow;

  R1 = not (CarsAllowed and Walk);
  R2 = not (Red and Green);
  R3 = Red or Yellow or Green;
  R4 = Walk => Red;
  R5 = Walk xor DontWalk;
  R6 = true -> not (Red and pre Green);
  R7 = true -> not (Walk and pre CarsAllowed);
  R8 = true -> not (CarsAllowed and pre Walk);
  R9 = true -> not (Yellow and pre Yellow);
  R10 = true -> (pre Red and not Red) => Green;
tel









----------------------------------------------------

-- Floor_i is true iff the elevator is at floor i

-- Door_Open is true iff the elevator's door is open

-- Call_i is true iff there is a call to go to floor i

-- The elevator moves only when the door is closed and the Stop button is not pressed.

-- The elevator will not pass the end positions, that is, go through the roof or the floor.

-- A moving elevator halts only if
  -- the Stop button is pressed, or the door is opened,
  -- or the elevator has arrived at the destination floor.

-- The elevator halts before changing direction.

-- The signals sent to the motor are not contradictory

node Control( Floor_1, Floor_2, Door_Open, Call_1, Call_2, Stop : bool )
returns ( Motor_Up, Motor_Down : bool);
var CanMove : bool;
let
--  CanMove = 

--  Motor_Up =

--  Motor_Down =
















  CanMove =  not Stop and not Door_Open ;

  Motor_Up =  CanMove and not Floor_2 and
              ((false -> pre Motor_Up) or Call_2) and
              not (false -> pre Motor_Down);

  Motor_Down =  CanMove and not Floor_1 and
                ((false -> pre Motor_Down) or Call_1) and
                not (false -> pre Motor_Up);
tel



node Environment( Motor_Up, Motor_Down : bool )
returns ( Floor_1, Floor_2 : bool );
var L : int;
let
  L = 0 -> if pre Motor_Up then (pre L) + 1
           else if pre Motor_Down then (pre L) - 1
           else pre L;

  Floor_1 =  L = 0;
  Floor_2 =  L = 5;
tel


node Simulate( Door_Open, Call_1, Call_2, Stop : bool )
returns ( Motor_Up, Motor_Down : bool );
var Floor_1, Floor_2 : bool;
let
  (Motor_Up, Motor_Down) = Control(Floor_1, Floor_2, Door_Open, Call_1, Call_2, Stop);

  (Floor_1, Floor_2) = Environment(Motor_Up, Motor_Down);
tel





node Requirements( Floor_1, Floor_2, Door_Open,
                   Call_1, Call_2, Stop : bool )
returns ( R1, R2, R3, R4, R5, R6 : bool );

var Motor_Up, Motor_Down:  bool;
  -- auxiliary streams
    Moving, Should_Move, Halts : bool;

let 
  (Motor_Up, Motor_Down)
   = Control(Floor_1, Floor_2, Door_Open, Call_1, Call_2, Stop);

  -- auxiliary streams
  -- Moves is true iff the elevator is moving now
  -- Halts is true iff the elevator has come to a stop







  Moving =  Motor_Up or Motor_Down;
  Halts =  not Moving and (false -> pre Moving);

  -- The elevator moves only when the door is closed and
  -- the Stop button is not pressed.


  -- The elevator will not pass the end positions, that is,
  -- go through the roof or the floor.


  -- A moving elevator halts only if
  -- the Stop button is pressed, or the door is opened,
  -- or the elevator has arrived at the destination floor.


  -- The elevator halts before changing direction.


  -- The signals sent to the motor are not contradictory

 


  R1 =  Moving => not Door_Open and not Stop;
  R2 =  (Floor_1 => not Motor_Down) and (Floor_2 => not Motor_Up);
  R3 =  Halts => (Stop 
                  or Door_Open
                  or ((true -> pre Motor_Down) and Floor_1)
                  or ((true -> pre Motor_Up) and Floor_2)
                 );
  R4 =  true ->
        (Motor_Up => (not pre Motor_Down))
        and (Motor_Down => (not pre Motor_Up));


  R5 =  not (Motor_Up and Motor_Down);



  

  -- The elevator moves when it should

  R6 =   Should_Move => Moving;

  
  Should_Move = false;




  -- The elevator should move iff
  -- (1) the elevator is at a floor, 
  -- (2) someone presses the Call button on the other floor,
  -- (3) no one presses the Stop button at the same time, and 
  -- (4) the door is closed, 

  -- Should_Move = ((Floor_1 and Call_2) or (Floor_2 and Call_1))
  --              and not Stop
  --              and not Door_Open
  --              and not (false -> pre Moving)
  --              and not (Floor_1 and Floor_2);
tel








-----------------------------------------------------------------


-- Show that
-- P1 - (Sofar(X) and Sofar(Y)) is equivalent to  
--      Sofar(X and Y)          for all Boolean streams X and Y.
--




-- P2 - (Sofar(X) or Sofar(Y)) is equivalent to  
--      Sofar(X or Y)          for all Boolean streams X and Y.

node SofarObs (X, Y: bool) returns (P2: bool);
let
  P2 =  (Sofar(X) or Sofar(Y)) = Sofar(X or Y);
tel



 
